# Лабораторная работа №3

  * Студент: `Силинцев Владислав Витальевич`
  * Группа: `P3314`
  * ИСУ: `355273`
  * Функциональный язык: `Clojure`
---

## Требования к разработанному ПО
- обязательно должна быть реализована линейная интерполяция
- настройки алгоритма интерполяции и выводимых данных должны задаваться через аргументы командной строки:
    - какие алгоритмы использовать (в том числе два сразу);
    - частота дискретизации результирующих данных;
    - и т.п.;
- входные данные должны задаваться в текстовом формате на подобии ".csv" (к примеру `x;y\n` или `x\ty\n`) и подаваться на стандартный ввод, входные данные должны быть отсортированы по возрастанию x;
- выходные данные должны подаваться на стандартный вывод;
- программа должна работать в потоковом режиме (пример – `cat | grep 11`), это значит, что при запуске программы она должна ожидать получения данных на стандартный ввод, и, по мере получения достаточного количества данных, должна выводить рассчитанные точки в стандартный вывод;

Приложение должно быть организовано следующим образом:

```text
    +---------------------------+
    | обработка входного потока |
    +---------------------------+
            |
            | поток / список / последовательность точек
            v
    +-----------------------+      +------------------------------+
    | алгоритм интерполяции |<-----| генератор точек, для которых |
    +-----------------------+      | необходимо вычислить         |
            |                      | промежуточные значения       |
            |                      +------------------------------+
            |
            | поток / список / последовательность рассчитанных точек
            v
    +------------------------+
    | печать выходных данных |
    +------------------------+
```

Потоковый режим для алгоритмов, работающих с группой точек должен работать следующим образом:

```text
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
        x x x . . o . . x x x
          x x x . . o . . x x x
            x x x . . o o o o o o EOF
```

где:

- каждая строка -- окно данных, на основании которых производится расчёт алгоритма;
- строки сменяются по мере поступления в систему новых данных (старые данные удаляются из окна, новые -- добавляются);
- `o` -- рассчитанные данные, можно видеть:
    - большинство окон используется для расчёта всего одной точки, так как именно в "центре" результат наиболее точен;
    - первое и последнее окно используются для расчёта большого количества точек, так лучших данных для расчёта у нас не будет.
- `.` -- точки, задействованные в рассчете значения `o`.
- `x` -- точки, расчёт которых для "окон" не требуется.

Общие требования:

- программа должна быть реализована в функциональном стиле;
- ввод/вывод должен быть отделён от алгоритмов интерполяции;
- требуется использовать идиоматичный для технологии стиль программирования.

## Ключевые элементы реализации
### Алгоритм линейной интерполяции:
```clojure
; Формула линейной интерполяции
(defn linear-y [x0 y0 x1 y1 x]
  (+ y0 (* (- x x0) (/ (- y1 y0) (- x1 x0)))))

; Линейная интерполяция
(defn linear-interpolation [points last-x step]
  (let [x0 (get-x (first points))
        y0 (get-y (first points))
        x1 (get-x (last points))
        y1 (get-y (last points))
        x-list (generate-x last-x x1 step x0)]
    (if (not= x0 x1)
      (map (fn [x] [x (linear-y x0 y0 x1 y1 x)]) x-list)
      nil)))
```

### Алгоритм метода Ньютона:
```clojure
; Разделённые разности для метода Ньютона
(defn divided-diff [points]
  (let [xs (map get-x points)
        ys (map get-y points)]
    (loop [level 0
           column ys
           result []]
      (if (= level (dec (count points)))
        (conj result (first column))
        (let [next-column
              (map (fn [f1 f0 x1 x0]
                     (/ (- f1 f0) (- x1 x0)))
                   (rest column)
                   (butlast column)
                   (drop (inc level) xs)
                   xs)]
          (recur (inc level)
                 next-column
                 (conj result (first column))))))))

; Формула метода Ньютона
(defn newtone-y [points coeffs x]
  (reduce
   (fn [sum [i c]]
     (let [xs (map get-x (subvec points 0 i))
           term (reduce * 1 (map #(- x %) xs))]
       (+ sum (* c term))))
   0
   (map-indexed vector coeffs)))

; Интерполяция методом Ньютона
(defn newtone-interpolation [points last-x step n]
  (if (< (count points) n)
    nil
    (let [window (subvec points 0 n)
          x0 (get-x (first window))
          x1 (get-x (last window))
          x-list (generate-x last-x x1 step x0)
          coeffs (divided-diff window)]
      (map (fn [x] [x (newtone-y window coeffs x)]) x-list))))
```

## Тестирование
### Тестирование линейной интерполяции:
```clojure
; Проверка линейной интерполяции
(deftest test-linear-interpolation
  (let [points [[0 0] [10 10]]
        res (interp/linear-interpolation points nil 2)
        expected [[0 0] [2 2] [4 4] [6 6] [8 8]]]
    (is (= (count expected) (count res)))
    (doseq [[[ex ey] [rx ry]] (map vector expected res)]
      (is (= ex rx))
      (is (equal-with-accuracy ey ry 1e-9)))))
```

### Тестирование метода Ньютона:
```clojure
; Проверка метода Ньютона
(deftest test-newtone-interpolation
  (let [points [[0 0] [1 1] [2 2]]
        res (interp/newtone-interpolation points nil 1 3)]
    (is (= 2 (count res)))
    (let [[[x1 y1] [x2 y2]] res]
      (is (= 0 x1))
      (is (= 1 x2))
      (is (equal-with-accuracy 0 y1 1e-9))
      (is (equal-with-accuracy 1 y2 1e-9)))))
```

## Ввод/вывод программы
- \< – ввод
- \> – вывод

### Работа при ключах `--step 0.7`, `--linear`:
```text
< 0 0
< 1 1
> linear: 0.0 0.0
> linear: 0.7 0.7
< 2 2
> linear: 1.4 1.4
< 3 3
> linear: 2.0999999999999996 2.0999999999999996
> linear: 2.8 2.8
< 4 4
> linear: 3.5 3.5 
> End of input
```

### Работа при ключах `--step 0.7`, `--newtone`, `-n 4`:
```text
< 0 0
< 1 1
< 2 2
< 3 3
> newtone: 0.0 0.0
> newtone: 0.7 0.7
> newtone: 1.4 1.4
> newtone: 2.0999999999999996 2.0999999999999996
> newtone: 2.8 2.8
< 4 4
> newtone: 3.5 3.5
> End of input
```

### Работа при ключах `--step 0.7`, `--linear`, `--newtone`, `-n 4`:
```text
< 0 0
< 1 1
> linear: 0.0 0.0
> linear: 0.7 0.7
< 2 2
> linear: 1.4 1.4
< 3 3
> linear: 2.0999999999999996 2.0999999999999996
> linear: 2.8 2.8
> newtone: 0.0 0.0
> newtone: 0.7 0.7
> newtone: 1.4 1.4
> newtone: 2.0999999999999996 2.0999999999999996
> newtone: 2.8 2.8
< 4 4
> linear: 3.5 3.5
> newtone: 3.5 3.5
> End of input
```

## Выводы
В ходе выполнения лабораторной работы были изучены и применены следующие возможности языка Clojure:
- Регулярные выражения (`#""`) — использованы для разбора строкового ввода и выделения числовых данных.
- Форма `doseq` — применена для последовательного обхода коллекций и вывода результатов без формирования нового значения.
- Ввод данных через `read-line` — реализовано чтение входных данных из стандартного потока.
- Обработка аргументов командной строки (`parse-opts` из `clojure.tools.cli`) — освоена передача параметров при запуске программы из терминала.
- Управляющие конструкции `when` и `do` — использованы для организации условного выполнения кода и группировки выражений.
- Функции работы с коллекциями (`first`, `last`, `rest`, `range`) — применены для обработки последовательностей данных.
- Функция `subvec` — использована для работы с подмножествами векторов без копирования данных.