# Лабораторная работа №3

  * Студент: `Силинцев Владислав Витальевич`
  * Группа: `P3314`
  * ИСУ: `355273`
  * Функциональный язык: `Clojure`
---

## Требования к разработанному ПО
- обязательно должна быть реализована линейная интерполяция
- настройки алгоритма интерполяции и выводимых данных должны задаваться через аргументы командной строки:
    - какие алгоритмы использовать (в том числе два сразу);
    - частота дискретизации результирующих данных;
    - и т.п.;
- входные данные должны задаваться в текстовом формате на подобии ".csv" (к примеру `x;y\n` или `x\ty\n`) и подаваться на стандартный ввод, входные данные должны быть отсортированы по возрастанию x;
- выходные данные должны подаваться на стандартный вывод;
- программа должна работать в потоковом режиме (пример – `cat | grep 11`), это значит, что при запуске программы она должна ожидать получения данных на стандартный ввод, и, по мере получения достаточного количества данных, должна выводить рассчитанные точки в стандартный вывод;

Приложение должно быть организовано следующим образом:

```text
    +---------------------------+
    | обработка входного потока |
    +---------------------------+
            |
            | поток / список / последовательность точек
            v
    +-----------------------+      +------------------------------+
    | алгоритм интерполяции |<-----| генератор точек, для которых |
    +-----------------------+      | необходимо вычислить         |
            |                      | промежуточные значения       |
            |                      +------------------------------+
            |
            | поток / список / последовательность рассчитанных точек
            v
    +------------------------+
    | печать выходных данных |
    +------------------------+
```

Потоковый режим для алгоритмов, работающих с группой точек должен работать следующим образом:

```text
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
        x x x . . o . . x x x
          x x x . . o . . x x x
            x x x . . o o o o o o EOF
```

где:

- каждая строка -- окно данных, на основании которых производится расчёт алгоритма;
- строки сменяются по мере поступления в систему новых данных (старые данные удаляются из окна, новые -- добавляются);
- `o` -- рассчитанные данные, можно видеть:
    - большинство окон используется для расчёта всего одной точки, так как именно в "центре" результат наиболее точен;
    - первое и последнее окно используются для расчёта большого количества точек, так лучших данных для расчёта у нас не будет.
- `.` -- точки, задействованные в рассчете значения `o`.
- `x` -- точки, расчёт которых для "окон" не требуется.

Общие требования:

- программа должна быть реализована в функциональном стиле;
- ввод/вывод должен быть отделён от алгоритмов интерполяции;
- требуется использовать идиоматичный для технологии стиль программирования.

## Ключевые элементы реализации
### Алгоритм линейной интерполяции:
```clojure
; Формула линейной интерполяции
(defn linear-y [x0 y0 x1 y1 x]
  (+ y0 (* (- x x0) (/ (- y1 y0) (- x1 x0)))))

; Фабрика алогиритма линейной интерполяция
(defn linear-algorithm []
  (let [last-x (atom nil)]
    (fn [points step]
      (when (>= (count points) 2)
        (let [p0 (nth points (- (count points) 2))
              p1 (last points)
              x0 (:x p0)
              y0 (:y p0)
              x1 (:x p1)
              y1 (:y p1)
              xs (generate-x @last-x x1 step x0)]
          (when-not (= x0 x1)
            (let [result
                  (map (fn [x]
                         {:x x
                          :y (linear-y x0 y0 x1 y1 x)})
                       xs)]
              (when (seq result)
                (reset! last-x (:x (last result))))
              result)))))))
```

### Алгоритм метода Ньютона:
```clojure
; Разделённые разности для метода Ньютона
(defn divided-diff [points]
  (let [xs (map get-x points)
        ys (map get-y points)]
    (loop [level 0
           column ys
           result []]
      (if (= level (dec (count points)))
        (conj result (first column))
        (let [next-column
              (map (fn [f1 f0 x1 x0]
                     (/ (- f1 f0) (- x1 x0)))
                   (rest column)
                   (butlast column)
                   (drop (inc level) xs)
                   xs)]
          (recur (inc level)
                 next-column
                 (conj result (first column))))))))

; Формула метода Ньютона
(defn newtone-y [points coeffs x]
  (reduce
   (fn [sum [i c]]
     (let [xs (map get-x (subvec points 0 i))
           term (reduce * 1 (map #(- x %) xs))]
       (+ sum (* c term))))
   0
   (map-indexed vector coeffs)))

; Фабрика алгоритма интепроляции методом Ньютона
(defn newtone-algorithm [n]
  (let [last-x (atom nil)]
    (fn [points step]
      (when (>= (count points) n)
        (let [window (subvec points (- (count points) n))
              x0 (:x (first window))
              x1 (:x (last window))
              xs (generate-x @last-x x1 step x0)
              coeffs (divided-diff window)
              result
              (map (fn [x]
                     {:x x
                      :y (newtone-y window coeffs x)})
                   xs)]
          (when (seq result)
            (reset! last-x (:x (last result))))
          result)))))
```

## Тестирование
### Тестирование линейной интерполяции:
```clojure
; Проверка линейной интерполяции через замыкание
(deftest test-linear-algorithm
  (let [points (mapv (fn [x] {:x x
                              :y x}) [0 10])
        algo (interp/linear-algorithm)
        res (algo points 2)  ;; вызываем замыкание с шагом 2
        expected (mapv (fn [x] {:x x
                                :y x}) [0 2 4 6 8])]
    (is (= (count expected) (count res)))
    (doseq [[e r] (map vector expected res)]
      (is (= (:x e) (:x r)))
      (is (equal-with-accuracy (:y e) (:y r) 1e-9)))))
```

### Тестирование метода Ньютона:
```clojure
; Проверка метода Ньютона через замыкание
(deftest test-newtone-algorithm
  (let [points (mapv (fn [x] {:x x
                              :y x}) [0 1 2])
        algo (interp/newtone-algorithm 3) ;; создаём замыкание с окном 3 точек
        res (algo points 1)]              ;; вызываем замыкание с шагом 1
    (is (= 2 (count res)))
    (let [[{x1 :x
            y1 :y}
           {x2 :x
            y2 :y}] res]
      (is (= 0 x1))
      (is (= 1 x2))
      (is (equal-with-accuracy 0 y1 1e-9))
      (is (equal-with-accuracy 1 y2 1e-9)))))
```

## Ввод/вывод программы
- \< – ввод
- \> – вывод

### Работа при ключах `--step 0.7`, `--linear`:
```text
< 0 0
< 1 1
> linear: 0.0 0.0
> linear: 0.7 0.7
< 2 2
> linear: 1.4 1.4
< 3 3
> linear: 2.0999999999999996 2.0999999999999996
> linear: 2.8 2.8
< 4 4
> linear: 3.5 3.5 
> End of input
```

### Работа при ключах `--step 0.7`, `--newtone`, `-n 4`:
```text
< 0 0
< 1 1
< 2 2
< 3 3
> newtone: 0.0 0.0
> newtone: 0.7 0.7
> newtone: 1.4 1.4
> newtone: 2.0999999999999996 2.0999999999999996
> newtone: 2.8 2.8
< 4 4
> newtone: 3.5 3.5
> End of input
```

### Работа при ключах `--step 0.7`, `--linear`, `--newtone`, `-n 4`:
```text
< 0 0
< 1 1
> linear: 0.0 0.0
> linear: 0.7 0.7
< 2 2
> linear: 1.4 1.4
< 3 3
> linear: 2.0999999999999996 2.0999999999999996
> linear: 2.8 2.8
> newtone: 0.0 0.0
> newtone: 0.7 0.7
> newtone: 1.4 1.4
> newtone: 2.0999999999999996 2.0999999999999996
> newtone: 2.8 2.8
< 4 4
> linear: 3.5 3.5
> newtone: 3.5 3.5
> End of input
```

## Выводы
В ходе выполнения лабораторной работы были изучены и применены следующие возможности языка Clojure:
- Регулярные выражения (`#""`) — использованы для разбора строкового ввода и выделения числовых данных.
- Форма `doseq` — применена для последовательного обхода коллекций и вывода результатов без формирования нового значения.
- Ввод данных через `read-line` — реализовано чтение входных данных из стандартного потока.
- Обработка аргументов командной строки (`parse-opts` из `clojure.tools.cli`) — освоена передача параметров при запуске программы из терминала.
- Управляющие конструкции `when` и `do` — использованы для организации условного выполнения кода и группировки выражений.
- Функции работы с коллекциями (`first`, `last`, `rest`, `range`) — применены для обработки последовательностей данных.
- Функция `subvec` — использована для работы с подмножествами векторов без копирования данных.
- Замыкания (closures) и атомы (`atom`) — применены для инкапсуляции изменяемого состояния внутри функций интерполяции, что позволило хранить информацию о последней обработанной координате `x` и обеспечило расширяемость алгоритмов без изменения внешнего кода.